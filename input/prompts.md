# Prompt Series  
**Project:** Excel Product Calculator → Python Product Calculator  

---

## GLOBAL CONTEXT

### Role and Objective  
You are a **Senior Python Engineer**.  
Goal: From the Excel file `Tariff_Calculator.xlsm`, create a **modular, pure‑Python product calculator** that produces identical results.  
The solution consists of **seven scripts** and several **.csv input files** (see table below).  
Your working directory is root.  
The Excel file is located in the `input` directory.  
All outputs generated by the LLM and by the scripts must be written to the project root directory.  


### Deliverables
| Code | File | Content | Acceptance Criteria |
|--------|-------|--------|---------------|
| EXCEL_TO_TEXT | `excel_to_text.py` | Extract cells & ranges → `excelcell.csv`, `excelrange.csv` | Both CSVs exist & have ≥ 1 row |
| VBA_TO_TEXT | `vba_to_text.py` | Extract all VBA modules → `Mod_*.txt` | All module files exist |
| DATA_EXTRACT | `data_extract.py` | Create `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv`, `tariff.py` | All files exist & have ≥ 1 data row |
| BASISFUNCT | `basfunct.py` | 1‑to‑1 port of the VBA base functions | pytest suite passes |
| AUSFUNCT | `outfunc.py` | Contains `NormGrossAnnualPrem()` and dependent functions and other similar premium functions | `NormGrossAnnualPrem()` test < 1 e‑6 deviation |
| CLI_RUNNER | `run_calc.py` | Command‑line interface | `python run_calc.py --help` runs |

### General Rules  
- **Language:** English in documentation, variable names in English (`present_value`).  
- **Quality:** Black formatting, Ruff lint = 0 warnings.  
- **Response format:** Each task delivers as many executable code blocks as defined in the relevant task.  
- **Progress:** Work **strictly step by step**. Complete each task, wait for my **“✅”**, only then continue. DO NOT START any coding if note explicitely instructed to!  


---

## TASK 1 – Implement Code for Context Export (Excel → CSV)

1. **Goal**: Create a simple script to tranlsate Excel-Content in text (`excel_to_text.py`)
2. **Input for the script**: `Tariff_Calculator.xlsm`  
3. **Output fo the script**  
   - `excelcell.csv` (columns: Sheet, Address, Formula, Value)  
   - `excelrange.csv` (columns: Sheet, Name, Address)  
4. **Procedure for the script**  
   - Use `xlwings` for array formulas.  
   - Ignore empty cells.  
   - Prerequisite: `xlwings` requires a local Excel installation.  
5. **Success Check**  
```python
assert Path("excelcell.csv").stat().st_size > 10_000
assert "Calculation" in pd.read_csv("excelcell.csv")["Sheet"].unique()
```  
6. **Delivery format**: Full, executable code block.

---

## TASK 2 – Implement Code for VBA Export (VBA → TXT)

1. **Goal**: Create a simple script to tranlsate Excel-VBA-Module-Content in text (`vba_to_text.py`)
2. **Input for the script**: `Tariff_Calculator.xlsm`  
3. **Output fo the script**: One `Mod_*.txt` file per VBA module  
4. **Procedure for the script**  
   - Use `oletools.olevba` or `vb2py` to dump the modules.  
   - Filename scheme: `Mod_<Name>.txt`.  
   - Process all non‑empty code modules, including those without `Sub` (e. g., with constants).    
   - Ignore empty modules or code objects (e. g., Excel worksheet without code).  
5. **Success Check**  
   - Number of `.txt` files ≥ number of non‑empty modules in the VBA editor.  
   - Each file contains at least one `Sub` or `Function`.

---

## TASK 3 – Implement Code to Extract Data from Excel via earlier produced .csv files

1. **Goal**: Create a simple script to create the extract of the relevant data (`data_extract.py`)  
2. **Input for LLM**: CSV files `excelcell.csv`, `excelrange.csv`  
3. **Input for the script**: CSV files `excelcell.csv`, `excelrange.csv`  
4. **Output of the script**  
   - `var.csv`  – Variables (sheet *Calculation*, A4:B9), contract‑specific  
   - `tariff.csv` – Tariff data (sheet *Calculation*, D4:E11), shared across multiple contracts  
   - `limits.csv` – Limits (sheet *Calculation*, G4:H5)  
   - `tables.csv` – MortalityTable (sheet *MortalityTables*, columns A–E, data starting in row 4, headers in row 3)  
   - `tariff.py`  – function **`ModalSurcharge(PayFreq)`** (Excel formula E12)  
5. **Procedure for the script**  
   - Read each listed cell block from the input files.  
   - Write CSVs exactly in the specified column formats.  
   - For scalar blocks (var.csv, tariff.csv, limits.csv), write a simple key–value CSV with columns Name and Value (one row per item).  
   - Export tables.csv in a structure that matches the Excel mortality table logically (index + columns + values). The script should infer which row contains headers and which column is the index based on the extracted Excel content. Avoid JSON-in-cell encodings.  
   - For CSVs, always include one column *Name* and one column *Value*.  
   - Implement `ModalSurcharge(PayFreq)` exactly according to the formula in cell E12.  
6. **Success Check**  
   - All files exist & have ≥ 1 data row (tables ≥ 100).  
   - `import tariff; tariff.ModalSurcharge(12)` returns the same value as Excel cell E12.

---

## TASK 4 – Implement Code to Generate Test Fixtures

1. **Goal**: Creat tests (`tests/conftest.py`, `tests/test_data_roundtrip.py`)
2. **Input for LLM**: Existing CSV files (`var.csv`, `tariff.csv`, `tariff.py`, `limits.csv`, `tables.csv`)  
3. **Input for the script**: Existing CSV files (`var.csv`, `tariff.csv`, `tariff.py`, `limits.csv`, `tables.csv`)  
4. **Output of LLM**: Folder `tests/` with pytest fixtures  
5. **Procedure**  
   - LLM create two separate code blocks, each per one script
   - `conftest.py` sets up temp directory & mini CSV samples.  
   - Smoke test `test_data_roundtrip.py` reads each CSV and counts columns.  
6. **Success Check**  
   - `pytest -q` runs green (0 errors, 0 failures).

---

## TASK 5A – Implement Code to Translate Base Functions

1. **Goal**: Translate VBA code into python
2. **Input for LLM**: All `Mod_*.txt` from TASK 2  
3. **Output of LLM**: `basfunct.py`  
4. **Procedure**  
   - Each VBA `Function`/`Procedure` is mapped 1‑to‑1 to a Python `def`.  
   - Use `pandas` for table/CSV access.  
   - No function body may end with `pass`.  
   - Available data sources for the python script: `excelcell.csv`, `excelrange.csv`, `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv`.

---

## TASK 5B – Implement Code for Function Parity Test

**Success Check**: LLM creates `tests/test_func_parity.py` that  
- collects all **public** VBA names (`Function`/`Sub` without `Private`),  
- scans Python `def` names in `basfunct.py` (helpers may be ignored),  
- and verifies that for each VBA name exactly one Python function exists.  
Passing = `pytest -q` runs completely green.

---

## TASK 6A – Implement Code for NormGrossAnnualPrem()

*(Premium calculation 1 of 4, Implementation)*

1. **Goal**: Recreate the Excel-Formula for the premium calculation in python

2. **Input for LLM**
   - `excelcell.csv` & `excelrange.csv` to extract the formula  
   - `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv` for LLM to undestand the structure of the input files

3. **Input for the script**
   - `basfunct.py`  
   - `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv`

4. **Output of the script**
   • Function `NormGrossAnnualPrem(sa, age, sex, n, t, PayFreq, tariff)` in `outfunc.py`

5. **Procedure**
   • Formula exactly as in Calculation!K5 (“Bxt”).
   • Dependencies: - Variables → `var.csv` - Tariff/Limits → `tariff.csv`, `limits.csv` - Base functions → `basfunct.py`.
   • Do not leave placeholders (`pass`).

6. **Success Check**

   For LLM: Test the results internally to make sure that the implementation ist correct - it should not be part of the script, only for LLM.

   **Reference input**

   | sa      | age | sex | n  | t  | PayFreq | tariff |
   | ------- | --- | --- | -- | -- | ------- | ------ |
   | 100 000 | 40  | "M" | 30 | 20 | 12      | "KLV"  |

   **Expected value**

   | Function              | Expected       | Tolerance  |
   | --------------------- | -------------- | ---------- |
   | NormGrossAnnualPrem() | **0.04226001** | ± 1 × 10⁻⁸ |

---

## TASK 6B – Implement Code for the Test

   Use the reference input and the expected values from Task 6A and create the test code.

   *LLM creates `tests/test_NormGrossAnnualPrem.py` that checks this single case.
   Passing = `pytest -q` shows a green test.*

---

## **TASK 6C – Implement Code Blocks for Additional Output Functions**

*(Premium calculation 2 – 4 of 4, Implementation)*

1. **Goal**: Recreate further Excel-Formulas for the premium calculation in python

2. **Input for LLM**
   - `excelcell.csv` & `excelrange.csv` to extract the formula  
   - `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv` for LLM to undestand the structure of the input files

3. **Input for the script**
   - `basfunct.py`  
   - `var.csv`, `tariff.csv`, `limits.csv`, `tables.csv`

4. **Output**
   `outfunc.py` (extended)
   – implement functions for cells **K6 (BJB), K7 (BZB), K9 (Pxt)**.

5. **Success Check**

   For LLM: Test the results internally to make sure that the implementation ist correct - it should not be part of the script, only for LLM.

   **Reference input** – the same as before.

   **Expected values**

   | Function          | Excel cell | Expected       | Tolerance  |
   | ----------------- | ---------- | -------------- | ---------- |
   | GrossAnnualPrem() | K6         | **4 226.00** € | ± 1 × 10⁻² |
   | GrossModalPrem()  | K7         | **371.88** €   | ± 1 × 10⁻² |
   | Pxt()             | K9         | **0.04001217** | ± 1 × 10⁻⁸ |


---

## **TASK 6D – Implement Code for the Tests**

   Use the reference input and the expected values from Task 6A and create three separate code blocks (as if from three prompts).  
   *LLM creates `tests/GrossAnnualPrem.py` that checks this single case.
   *LLM creates `tests/GrossModalPrem.py` that checks this single case.
   *LLM creates `tests/Pxt.py` that checks this single case.
   Passing = `pytest -q` shows a green test.*


---

## **TASK 7 – Implement Code for CLI Runner (`run_calc.py`)**

> *Goal:* Provide a minimal, reproducible command-line runner that executes the
> output functions implemented in **TASK 6A–6D**.
>  
> At this stage, only **NormGrossAnnualPrem** is guaranteed to be fully implemented;
> all other functions may still be placeholders.
>  
> The CLI is intended as a **technical execution and validation tool**, not as a UI.
> All results are printed directly to the terminal.

---

### 1. Input

- Python modules  
  - `outfunc.py`  
  - functions implemented in **TASK 6A–6D**
- CSV input files (created in **TASK 3**)  
  - `var.csv`  
  - `tariff.csv`  
  - `limits.csv`  
  - `tables.csv`  

---

### 2. Output

- Script **`run_calc.py`**
- Fully functional `--help` output generated via `argparse`
- Calculation results printed to **STDOUT only**

---

### 3. Procedure

#### 3.1 Command-line interface

Implement a CLI using `argparse` with the following parameters:

| Type | Parameter | Description |
|-----|-----------|-------------|
| File | `--var-file` *(default: `var.csv`)* | alternative variables file |
| File | `--tariff-file` *(default: `tariff.csv`)* | alternative tariff file |
| List | `--funcs` *(e.g. `NormGrossAnnualPrem,GrossAnnualPrem,GrossModalPrem,Pxt`)* | run only these functions |
| Flag | `--all` *(default)* | compute all available functions |

Calling

```bash
python run_calc.py --help
```

must list all options with short descriptions.

---

#### 3.2 Input loading

- Load `var.csv` and `tariff.csv` (or alternative paths) using `pandas`.
- Required input variables (defined in **TASK 3** and used in **TASK 6A–6D**):

```
sa, age, sex, n, t, PayFreq, tariff
```

- Read values **case-insensitively** from the columns:
  - `Name` or `Variable`
  - `Value`

Convert numeric values to appropriate Python types (`int` / `float`).

---

#### 3.3 Function selection

Define the set of known output functions (aligned with **TASK 6A–6D**):

```python
ALL_FUNCS = [
    "NormGrossAnnualPrem",
    "GrossAnnualPrem",
    "GrossModalPrem",
    "Pxt",
]
```

Determine which functions to run:

```python
funcs_to_run = ALL_FUNCS if args.all or not args.funcs else args.funcs.split(",")
```

---

#### 3.4 Dynamic dispatch

Dynamically import functions from `outfunc.py`:

```python
from importlib import import_module
funcs = {name: getattr(import_module("outfunc"), name, None) for name in funcs_to_run}
```

For each function:

```python
if func is None or func.__doc__ == "PLACEHOLDER":
    results[name] = "not yet implemented"
else:
    results[name] = func(**input_args)
```

This behavior is consistent with the staged implementation approach used in
**TASK 6A–6D**.

---

#### 3.5 Output format

- Print results **only to STDOUT**
- Use compact JSON encoding:

```python
import json
print(json.dumps(results, ensure_ascii=False))
```

No files are written, no Excel interaction is performed.

---

### 4. Success Check

#### Default call

```bash
python run_calc.py
```

Expected output (example):

```json
{
  "NormGrossAnnualPrem": 0.04226001,
  "GrossAnnualPrem": "not yet implemented",
  "GrossModalPrem": "not yet implemented",
  "Pxt": "not yet implemented"
}
```

---

#### Subset call

```bash
python run_calc.py --funcs NormGrossAnnualPrem
```

```json
{
  "NormGrossAnnualPrem": 0.04226001
}
```

---

#### Alternative variables file

```bash
python run_calc.py --var-file my_vars.csv --funcs NormGrossAnnualPrem
```

→ values are taken from `my_vars.csv`.

---

### Passing Criteria

- All calls run without traceback
- `NormGrossAnnualPrem` matches the reference value from **TASK 6A**
  (`0.04226001 ± 1e-8`)
- Non-implemented functions return `"not yet implemented"`
- Output is deterministic and printed to the terminal only

4. **Success Check**
   - **Default call** (reads `var.csv`, `tariff.csv`):  
     ```bash
     python run_calc.py
     # → {"NormGrossAnnualPrem": 0.04226001, "GrossAnnualPrem": "not yet implemented", ...}
     ```
   - **Subset call**  
     ```bash
     python run_calc.py --funcs NormGrossAnnualPrem
     # → {"NormGrossAnnualPrem": 0.04226001}
     ```
   - **Alternative variables file**  
     ```bash
     python run_calc.py --var-file my_vars.csv --funcs NormGrossAnnualPrem
     ```
     → uses values from `my_vars.csv`.
   - `python run_calc.py --help` lists all options with description & example.

*Passing* = all three calls work without traceback;  
NormGrossAnnualPrem value matches the reference (0.04226001 ± 1e‑8); not implemented functions return `"not yet implemented"`.

---

## **TASK 8+ – Implement Code for Progression values  (11 functions - later to be implemented)**

1. **Input**  
   • Finished premium functions (6A, 6B)  
   • `basfunct.py` + all CSVs

2. **Output**  
   • Function `progr_vals(sa, age, sex, n, t, PayFreq, tariff)` in `outfunc.py`  
     – DataFrame with columns **B15:L15** of the sheet “Calculation”.

3. **Procedure**  
   • For each *k = 0 … n*, compute all progression values (`Axn`, `axn`, `axt`, `kVx_pp`, …).  
   • Column names & order exactly as in Excel.

4. **Success Check**  
   **Reference input** – same as above.  

   **Expected values (excerpt)**

   | k | Axn       | axn        | axt        | Tolerance |
   |---|-----------|------------|------------|----------|
   | 0 | **0.6315923** | **21.4202775** | **16.3130941** | ± 1 × 10⁻⁶ |
   | 1 | **0.6417247** | **20.8311476** | **15.6212042** | ± 1 × 10⁻⁶ |

   *LLM generates `tests/test_verlauf.py`:  
   – calls `progr_vals()` with the reference parameters,  
   – checks columns `Axn`, `axn`, `axt` for k = 0 and 1.  
   Passing = `pytest -q` without errors.*
